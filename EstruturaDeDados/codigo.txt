class No:
    def __init__(self, valor):
        self.valor = valor
        self.proximo = None
        self.anterior = None


class ListaDuplamenteEncadeada:
    def __init__(self):
        self.cabeca = None
        self.cauda = None
        self.cursor = None

    def acessarAtual(self):
        if self.cursor:
            return self.cursor.valor
        return None

    def InserirAntesDoAtual(self, novo):
        novo_no = No(novo)
        if self.cursor is None:
            return
        
        novo_no.anterior = self.cursor.anterior
        novo_no.proximo = self.cursor
        
        if self.cursor.anterior:
            self.cursor.anterior.proximo = novo_no
        else:
            self.cabeca = novo_no
        
        self.cursor.anterior = novo_no

    def InserirApósAtual(self, novo):
        novo_no = No(novo)
        if self.cursor is None:
            return
        
        novo_no.proximo = self.cursor.proximo
        novo_no.anterior = self.cursor
        
        if self.cursor.proximo:
            self.cursor.proximo.anterior = novo_no
        else:
            self.cauda = novo_no
        
        self.cursor.proximo = novo_no

    def inserirComoUltimo(self, novo):
        novo_no = No(novo)
        if self.cauda:
            self.cauda.proximo = novo_no
            novo_no.anterior = self.cauda
            self.cauda = novo_no
        else:
            self.cabeca = novo_no
            self.cauda = novo_no
        
        self.cursor = novo_no  # opcional, move o cursor para o novo nó

    def inserirComoPrimeiro(self, novo):
        novo_no = No(novo)
        if self.cabeca:
            novo_no.proximo = self.cabeca
            self.cabeca.anterior = novo_no
            self.cabeca = novo_no
        else:
            self.cabeca = novo_no
            self.cauda = novo_no
        
        self.cursor = novo_no  # opcional, move o cursor para o novo nó

    def inserirNaPosicao(self, k, novo):
        novo_no = No(novo)
        if k == 0:
            self.inserirComoPrimeiro(novo)
            return
        
        atual = self.cabeca
        pos = 0

        while atual and pos < k:
            atual = atual.proximo
            pos += 1

        if atual is None:  # Adiciona no final
            self.inserirComoUltimo(novo)
        else:
            novo_no.anterior = atual.anterior
            novo_no.proximo = atual
            
            if atual.anterior:
                atual.anterior.proximo = novo_no
            atual.anterior = novo_no
            
            if novo_no.anterior is None:  # Se foi o novo cabeçalho
                self.cabeca = novo_no

    def ExcluirAtual(self):
        if self.cursor is None:
            return
        
        if self.cursor.anterior:
            self.cursor.anterior.proximo = self.cursor.proximo
        else:
            self.cabeca = self.cursor.proximo
        
        if self.cursor.proximo:
            self.cursor.proximo.anterior = self.cursor.anterior
        else:
            self.cauda = self.cursor.anterior
            
        self.cursor = self.cursor.proximo  # Move o cursor para o próximo

    def ExcluirPrim(self):
        if self.cabeca is None:
            return
        
        self.cursor = self.cabeca
        self.ExcluirAtual()

    def ExcluirUlt(self):
        if self.cauda is None:
            return
        
        self.cursor = self.cauda
        self.ExcluirAtual()

    def ExcluirElem(self, chave):
        atual = self.cabeca
        while atual:
            if atual.valor == chave:
                self.cursor = atual
                self.ExcluirAtual()
                return
            atual = atual.proximo

    def ExcluirDaPos(self, k):
        atual = self.cabeca
        pos = 0

        while atual and pos < k:
            atual = atual.proximo
            pos += 1
        
        if atual:
            self.cursor = atual
            self.ExcluirAtual()

    def Buscar(self, chave):
        atual = self.cabeca
        while atual:
            if atual.valor == chave:
                return True
            atual = atual.proximo
        return False

    def avançarKPosições(self, k):
        for _ in range(k):
            if self.cursor and self.cursor.proximo:
                self.cursor = self.cursor.proximo
            else:
                break  # Chegou ao final da lista

    def retrocederKPosições(self, k):
        for _ in range(k):
            if self.cursor and self.cursor.anterior:
                self.cursor = self.cursor.anterior
            else:
                break  # Chegou ao início da lista

    def irParaPrimeiro(self):
        self.cursor = self.cabeca

    def irParaUltimo(self):
        self.cursor = self.cauda
